#!/bin/bash

#
# Copyright (c) 2018, Carnegie Mellon University.
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
# 3. Neither the name of the University nor the names of its contributors
#    may be used to endorse or promote products derived from this software
#    without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
# A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT
# HOLDERS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
# OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
# AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
# WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
#

#
# run_combo_mercury_runner.sh.in  local/remote mercury_runner tests
# 12-Jan-2018  chuck@ece.cmu.edu
#
# this is a revised version of run_mercury_runner.sh and
# and run_local_mercury_runner.sh (combines the two).  also
# takes params from environment
#

### instant death on misc errors ###
set -euo pipefail

####################
# Input parameters #
####################
subnet=${1:-"10.92"}    # 10.92=narwhal, 10.53=susitna_fge, 11.128=trinitite

# mode (one way or two way)
if [ ${MR_TWOWAY:-"0"} = "0" ]; then
  nb_mode="s"          # unidirectional
else
  nb_mode="cs"         # bidirectional (but we only report 1 direction)
fi

# "n" - normal send run: RPC, vary request size and limit
n_protos=(${MR_NPROTOS:-bmi+tcp cci+tcp})     # protocols to test
n_sizes=(${MR_NSIZES:-64 1024 4096})          # RPC snd size ("-i" flag)
n_limits=(${MR_NLIMITS:-1 2 4 8 16})          # outstanding RPCs ("-l" flag)
n_repeats=${MR_NREPEATS:-2}                   # repeat runs
n_nrpcs=${MR_NRPCS:-100000}                   # nrpcs in 1 run ("-c" flag)
n_timeout=${MR_NTIMEOUT:-120}                 # timeout  ("-t" flag)

# "b" - bulk read run: RPC, vary bulk read size and limit
b_protos=(${MR_BPROTOS:-bmi+tcp cci+tcp})     # protocols to test
b_Sizes=(${MR_BSIZES:-2m})                    # bulk sizes ("-S" flag)
b_limits=(${MR_BLIMITS:-1 2})                 # outstanding RPCs ("-l" flag)
b_repeats=${MR_BREPEATS:-2}                   # repeat runs
b_nrpcs=${MR_BRPCS:-10000}                    # nrpcs in 1 run ("-c" flag)
b_timeout=${MR_BTIMEOUT:-300}                 # timeout  ("-t" flag)

dryrun=0                                        # set to 1 for script debug

instances=(1)                                   # currently not changing this

###############
# Core script #
###############
###source @CMAKE_INSTALL_PREFIX@/scripts/common.sh
source /proj/TableFS/testXYZ/scripts/common.sh      # XXXCDC DEBUG

message "Script begin..."
# keep track of start time so we can see how long this takes
timein=`date`

get_jobdir
gen_hostfile

runner="${dfsu_prefix}/bin/mercury-runner"

message ">>> Output is available in $jobdir"

if [ ${num_all_nodes} = 1 -o ${MR_LOCAL:-0} != 0 ]; then
    message ">>> RUN TYPE = local"
    islocal=1
else
    message ">>> RUN TYPE = network"
    islocal=0
fi

#
# convert hostnames to IPs using hostname -I on remote nodes
# and put results in host*-ips.txt in $jobdir, load into
# host1_ip and host2_ip, also taking $subnet into consideration
#
host1=$(echo "$all_nodes" | sort | head -n 1)
do_mpirun 1 1 "" $host1 "hostname -i" "" $logfile $jobdir/host1-ips.txt
host1_ip=$(cat $jobdir/host1-ips.txt | tr ' ' '\n' | grep $subnet | head -1)
if [ -z $host1_ip ]; then die "wrong subnet"; fi
message ">>> Host 1: hostname = $host1, ip = $host1_ip"

if [ $islocal = 0 ]; then
    host2=$(echo "$all_nodes" | sort | head -n 2 | tail -n 1)
    do_mpirun 1 1 "" $host2 "hostname -i" "" $logfile $jobdir/host2-ips.txt
    host2_ip=$(cat $jobdir/host2-ips.txt | tr ' ' '\n' | grep $subnet | head -1)
    if [ -z $host2_ip ]; then die "wrong subnet"; fi
    message ">>> Host 2: hostname = $host2, ip = $host2_ip"
fi

#
# run_one: run one instance
#
# uses: jobdir, host1, host2, host1_ip, host2_ip, dryrun
# Arguments:
# @1 protocol to use
# @2 number of mercury instances
# @3 req size ("-s")
# @4 bulk send size ("-S")
# @5 outstanding RPC limit ("-l")
# @6 current current iteration number
# @7 number of rpcs ("-c")
# @8 number repeats we target
# @9 timeout
run_one() {
    proto="$1"
    num="$2"
    reqsz=$3
    bulksz=$4
    limit=$5
    iter=$6
    nrpcs=$7
    repeats=$8
    timeo=$9

    now=`date`

    message ""
    message "====================================================="
    message "Starting new test at: ${now}"
    message "Testing protocol '$proto' with $num Mercury instances"
    message "reqsz=${reqsz:-'n/a'}, bulksz=${bulksz:-'n/a'}, limit=$limit, nrpcs=$nrpcs"
    message "Iteration $iter out of $repeats, mode ${nb_mode}"
    message "====================================================="
    message ""

    if [ $islocal = 1 ]; then
        if [ $proto = "ofi+gni" -o $proto = "bmi+tcp" ]; then
            message "NOTE: applying local ofi+gni/bmi+tcp HACK..."
            saddress="${proto}://${host1_ip}:22222"
            caddress="${proto}://${host1_ip}:22223"
            cmd="$runner"
        else
            saddress="h0=${proto}"
            caddress="h1=${proto}"
            cmd="$runner -d ${jobdir}"
        fi
    else
        saddress="${proto}://${host1_ip}:%d"
        caddress="${proto}://${host2_ip}:%d"
        cmd="$runner"
    fi

    # generate log file names (maybe they should be passed in?)
    if [ ! -d $jobdir/$proto ]; then
        mkdir -p $jobdir/$proto
    fi
    if [ x$bulksz != x ]; then
        clogfile=$jobdir/$proto/bcli-$proto-$num-$bulksz-$limit-$iter-log.txt
        slogfile=$jobdir/$proto/bsrv-$proto-$num-$bulksz-$limit-$iter-log.txt
    else
        clogfile=$jobdir/$proto/ncli-$proto-$num-$reqsz-$limit-$iter-log.txt
        slogfile=$jobdir/$proto/nsrv-$proto-$num-$reqsz-$limit-$iter-log.txt
    fi
    # build command line
    # use slogfile for log; we'll move .0/.1 at the end
    cmd="$cmd -c ${nrpcs} -l $limit -M -q -r $iter -s $slogfile -t ${timeo}"
    if [ x$bulksz != x ]; then
        cmd="$cmd -S $bulksz -L $bulksz"
    fi
    if [ x$reqsz != x ]; then
        cmd="$cmd -i $reqsz"
    fi

    the_cmd="$cmd -m ${nb_mode} $num $saddress $caddress"
    # start the run
    message "!!! NOTICE !!! starting run (Instances: $num, Address spec: $saddress/$caddress)..."
    if [ $dryrun = 1 ]; then
        message "DRYRUN CMD = $the_cmd"
    else
        if [ $islocal = 1 ]; then
            do_mpirun 2 2 "" "$host1,$host1" "$the_cmd" "" "$logfile" || \
              message "!!! NOTICE !!! app exited with error code"
        else
            do_mpirun 2 1 "" "$host1,$host2" "$the_cmd" "" "$logfile" || \
              message "!!! NOTICE !!! app exited with error code"
        fi
    fi

    sleep 0.1

    # Collect return codes
    if [ x$dryrun != x ]; then
        the_ret=0      # fake return values
    else
        the_ret=$?
    fi

    if [[ $the_ret != 0 ]]; then
        message "!!! ERROR !!! program returned $the_ret."
    else
        message "Test completed successfully."
    fi

    # now put logs in correct place
    if [ -f ${slogfile}.0 ]; then
        mv ${slogfile}.0 $slogfile
    fi
    if [ -f ${slogfile}.1 ]; then
       mv ${slogfile}.1 $clogfile
    fi

    now=`date`
    message "Finished at ${now}"
}

# do normal test first
now=`date`
message "== Starting normal tests: ${now}"
for proto in ${n_protos[@]-}; do
    if [ $proto = "none" ]; then
        continue;
    fi
    for num in ${instances[@]-}; do
        for sz in ${n_sizes[@]-}; do
            for lm in ${n_limits[@]-}; do

                if [[ $proto == "bmi+tcp" && $num -gt 1 ]]; then
                    continue;  # BMI doesn't do well with >1 instances
                fi

                i=1
                while [ $i -le $n_repeats ]; do
                    run_one $proto $num $sz "" $lm $i $n_nrpcs \
                            $n_repeats $n_timeout
                    i=$((i + 1))
                done

            done
        done
    done
done
now=`date`
message "DONE normal tests: ${now}"

message "Generate result files"
for proto in ${n_protos[@]-}; do
    if [ $proto = "none" ]; then
        continue;
    fi
    for num in ${instances[@]-}; do
        for sz in ${n_sizes[@]-}; do
            find ${jobdir}/${proto} -iname "n*-${proto}-${num}-${sz}-*" | xargs cat | \
                ${dfsu_prefix}/scripts/process_runner.pl > \
                ${jobdir}/norm-${proto}-${num}-${sz}.result
            if [ ! -s ${jobdir}/norm-${proto}-${num}-${sz}.result ]; then
                message "!!! WARN !!! NO RESULTS: ${jobdir}/norm-${proto}-${num}-${sz}"
                rm -f ${jobdir}/norm-${proto}-${num}-${sz}.result
            fi
        done
    done
done
message "DONE generate result files"


# do bulk test next
now=`date`
message "== Starting bulk tests: ${now}"
for proto in ${b_protos[@]-}; do
    if [ $proto = "none" ]; then
        continue;
    fi
    for num in ${instances[@]-}; do
        for sz in ${b_Sizes[@]-}; do
            for lm in ${b_limits[@]-}; do

                if [[ $proto == "bmi+tcp" && $num -gt 1 ]]; then
                    continue;  # BMI doesn't do well with >1 instances
                fi

                i=1
                while [ $i -le $b_repeats ]; do
                    run_one $proto $num "" $sz $lm $i $b_nrpcs \
                            $b_repeats $b_timeout
                    i=$((i + 1))
                done

            done
        done
    done
done
now=`date`
message "DONE bulk tests: ${now}"

message "Generate result files"
for proto in ${b_protos[@]-}; do
    if [ $proto = "none" ]; then
        continue;
    fi
    for num in ${instances[@]-}; do
        for sz in ${b_Sizes[@]-}; do
            find ${jobdir}/${proto} -iname "b*-${proto}-${num}-${sz}-*" | xargs cat | \
                ${dfsu_prefix}/scripts/process_runner.pl > \
                ${jobdir}/bulk-${proto}-${num}-${sz}.result
            if [ ! -s ${jobdir}/bulk-${proto}-${num}-${sz}.result ]; then
                message "!!! WARN !!! NO RESULTS: ${jobdir}/bulk-${proto}-${num}-${sz}"
                rm -f ${jobdir}/bulk-${proto}-${num}-${sz}.result
            fi
        done
    done
done
message "DONE generate result files"

message "== Listing results ..."
for result in $(find $jobdir -iname "*.result"); do
    message ""
    message "$result"
    cat $result | tee -a $logfile
    message ""
    message "----------"
done
message "DONE listing results"

# overall time
timeout=`date`
message "Script complete."
message "start: ${timein}"
message "  end: ${timeout}"

exit 0
